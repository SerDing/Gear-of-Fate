
# 0.GameManager
	
	该模块负责整合、处理整个游戏世界 

	update及Render方法中主要负责处理不同游戏进度下不同的游戏内容的更新和展示

# 1.ResManager

	该模块是为了实现资源的统一化 降低不同模块中重复载入相同资源的可能性 使游戏
	
	占用RAM资源达到最小化

# 2.GameScreen

	该模块负责将 map character hud GUI 等模块整合到一起

# 3.Map

	负责地图的读取加载 配合角色的碰撞检测 ……

# 4.Effect 

	特效管理目前尚无好的构思


============================================

# 资源管理器架构参考

        可以写一个纹理资源管理类来管理所有的纹理。程序需要载入纹理的时候，调用资源管理类去加载，资源管理类首先检查目标纹理是不是已经被加载了，如果已经加载的话，直接返回指针，否则的话加载纹理纹理文件返回指针。其中要注意的是卸载纹理的时候，最好是为每一个纹理加一个引用计数，以防一个类把纹理卸载以后另一个类访问出错。

        一般来说，一个角色的一个动作序列是保存在同一个纹理的不同区域中的，使用的时候需要两个数据，一个是纹理的指针，一个是图像在纹理中的位置矩形，绘制的时候只要把那个矩形内的图像复制到表面就可以了。 






# 架构参考资料


# 游戏开发中的几个要素
  

# 一、游戏首要的要素便是角色，如果将角色归纳为一个MVC架构的话：
        1、模型便是角色的位置信息，属性之类的。
        2、视图则是一些图片集合，有规则的组合它们，将它们分成若干组，那么每一组就是一个动作。每个组有若干张图片，一般的它们通过时间来决定应该怎样呈现这个视图（亦即显示哪张图片）。可以设置动作，让这个视图有不同的行为。一般的，我们称这个视图为精灵(Sprite)，精灵将在另一篇文章中描述。
        3、控制器就是用来设置角色动作的。它有可能是对精灵的一个简单的代理，假如控制器设置角色状态为行走，那么可能控制器只是简单的调用了精灵的setAction(ActionRun)方法，并且有精灵自己去设置速度。     当然也可以这样去实现控制器，一方面它通过代理设置精灵的动作，同时也去修改对象的物理属性。控制器可能由玩家来操作，也有可能由NPC的A.I.进行操作，也有可能来自网络。
  

# 二、接下去比较重要的便是地图模块。对于地图，目前只把它当成一个MV结构。
        1、模型层：地图一般有各种碰撞线或者每个块有不同的状态（比如能否通过该块），所以这些状态都应该保存在地图的模型中。
        2、视图层：地图一般通过外部的编辑工具来设计的。一般的，地图很少在游戏过程中变动，所以将它直接保存在内存中的一张图片中。对于地图怎么创建的，将在另一篇文章描述。

  
# 三、物理引擎。
        物理引擎一般对对象进行碰撞检测，以及改变对象的运动状态。对于一些简单的游戏，只要设计简单的物理引擎就可以了。对于对物理效果要求比较高的游戏，最好套用现成的比较成熟的引擎。

  
# 四、用户界面元素。
        这个模块提供各种窗口，按钮来供交互。

  
# 五、游戏的“Holder ”：
        它是游戏的持有者，它持有几乎所用的游戏对象，它维护游戏的正常运作。它与资源管理器协同完成游戏对象（比如窗口，角色，地图）的创建，以及释放资源。它定时驱动渲染线程，解析角色的动作，我这里它组合有物理引擎。

  
# 六、游戏的资源管理器。
         游戏运行过程中需要大量的图片相关的资源。而且很多游戏中，一个相同造型的角色会有好几份拷贝，如果没有进行良好的设计的话，这些角色就会持有不同的图片资源的拷贝。因此特意设计了资源管理器，GameHolder创建对象时，都会向资源管理器申请资源，如果该资源已经加载到内存中了，就会返回资源的引用；如果没有，就会载入该资源。


# NPK资源文件直读进度
        初步了解：
        所需关键技术:
                luajit-ffi --> 字节集类
                debase64() -- base64文本解码
                uncompress() -- zlib数据解压算法