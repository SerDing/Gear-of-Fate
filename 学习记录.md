<font face="微软雅黑">
#命名标准

###1.源代码文件命名

	由开头大写的单词组成，涉及数字时，使用下划线“_”隔开

``` lua
	example
	io.open("Ani_1.lua")
```

###2.类名与函数名

	由开头大写的单词组成,单例类使用全大写

``` lua
	example
	local _GAMEMGR = {}
```

###3.变量命名

	小写开头，遵循驼峰命名法，私有变量(private)前面加“_”标示

``` lua
	example
	_tile = "Gear"
```
***************************

#注释标准

###1.尽量使用全英文
###2.给类和函数写Doc时写注释
###3.需要__特殊注意__的地方写注释
#####note:注释不需要做到解释代码的程度，因为代码本身就表达了信息。

#lua编程习惯注意

#####1.不要使用全局变量，local定义的局部变量效率更高且可以提高模块内聚性
#####2.使用require方法加载lua模块，可以很清楚的知道对外部的引用情况，为维护提供极大便利。

```lua

	local _RESMGR = require("Src/ResMgr")
	local _ActorBase = require("Src/Actor")

```
#####3.局部变量的开发思想实质上就是模块化
#####4.每个变量都应在对应的模块内，不能越界。
```lua
	错误的做法
	GameMgr.lua

	local _GAMEMGR = require("Src.Class")()
	Game.imageCachePool = {} -- 出现了全局变量且发生越界

----------------------------------------------------------------------

	正确的做法
	ResMgr.lua

	local _RESMGR = require("Src.Class")()
	self.imageCachePool = {}

```
#####5.单例类不用class化，只需使用空table定义即可
	单例类特指那些只出现一个实例的类，它们既不会重复出现，也不会作为基类存在，没有重用价值，因此不必class化，为其添加继承或重用的特性。
```lua
	
	example
	
	local _GAMEMGR = {
		
		tile = "Gear Of Fate",
		
		debug = false,
		
		keyboardIni = {}
	}

	local _RESMGR = {}
```
#####6.Class中变量类型的定义方法
```lua
	public

	local _RESMGR = {} --单例类，纯table
	_RESMGR.imageCachePool = {}

-------------------------------------------------------

	private

	local _RESMGR ={} 
	
	function _RESMGR.Ctor()
		local _imageCachePool = {}
	end 

```
#####7.table特性
	在lua中，table之间通过等号只能是一种引用，即复制根源变量的内存地址，而非变量内容的纯粹复制。
```lua
	
	example

	a = {x = 0}

	b = a

	b.x = 3

	print(a.x)

	输出结果不是0，而是3
```
	也就是说，b只是a传递出来的一个内存地址而已 
	
	b.x = 3 实质上会回到a中对a的x进行操作
	
	而当我们在一个文件中 local 定义类变量 最后再 return 它 
	
	那么当我们在外部需要使用它时，便可用require将其地址传递出来
	
	保存到一个新的变量中
	
```lua
	Mgr.lua

	local _MGR = {}

	_MGR.imageNum = 10

------------------------------------------------------------------
	
	ResPack.lua

	local _ResPack = require("Class")()

		local _MGR = require("Mgr")

	function _ResPack:Ctor()
		........
	end 

```
	在这里，看上去每次创建一个新的ResPack都会为其新建一个对应的MGR，
	
	实际上这种想法是错误的！
	
	(第一次require("Mgr")时，会在Mgr.lua文件内建立_MGR变量
	
	再次require时，就只会返回_MGR地址)
	
	ResPack.lua开头部分对Mgr的require只是为了将Mgr.lua中的_MGR地址传递出来
	
	方便使用而已，本质上并不是新建，而是添加了一个新的引用指针。
	
	正是通过这种方法 模块之间得以形成清晰的联系，同时又避免了严重的耦合。
	
	在这里这种一个MGR被多个ResPack引用的树形引用关系恰好就形成了
	
	MGR所需要的一种管理效应。



#程序开发流程

###1.需求分析（Need）
#####书写需求文档
#####确定功能函数（如：GameMgr包含 Ctor Update Draw …… ）
#####确定包含的数据（如：GameMgr包含 title period screenOffset …… ）
#####确定包含的单元(如：GameMgr包含GameMap HUD UI MonsterProducer……)
#####确定模块性质（如：GameMgr是游戏的核心单元，它是所有大型单元Update和Draw的场所）
#####使用astah pro 绘制UML图，理清各模块之间的关系（继承，组合……）

###2.编程实现
#####定义初期策划好的所有接口
#####逐一编写接口内业务逻辑
#####Debug

##参考资料：80/20 rule 思考代码时间占80% 编写时间占20% 这是一种必要的思维方式

###PS：基础薄弱 勤能补拙

</font>







