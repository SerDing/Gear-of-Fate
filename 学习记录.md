<font face="微软雅黑">

# 命名标准


1.源代码文件命名

	由开头大写的单词组成，涉及数字时，使用下划线“_”隔开

``` lua
	example
	io.open("Ani_1.lua")
```

### 2.类名与函数名

	由开头大写的单词组成,单例类使用全大写

``` lua
	example
	local _GAMEMGR = {}
```

### 3.变量命名

	小写开头，遵循驼峰命名法，私有变量(private)前面加“_”标示

``` lua
	example
	local _tile = "Gear"
```
***************************

# 注释标准

### 1.尽量使用全英文
### 2.给类和函数写Doc时写注释
### 3.需要__特殊注意__的地方写注释
##### note:注释不需要做到解释代码的程度，因为代码本身就表达了信息。

# lua编程习惯注意

##### 1.不要使用全局变量，local定义的局部变量效率更高且可以提高模块内聚性
##### 2.使用require方法加载lua模块，可以很清楚的知道对外部的引用情况，为维护提供极大便利。

```lua

	local _RESMGR = require("Src/ResMgr")
	local _ActorBase = require("Src/Actor")

```
##### 3.局部变量的开发思想实质上就是模块化
##### 4.每个变量都应在对应的模块内，不能越界。
```lua
	错误的做法
	GameMgr.lua

	local _GAMEMGR = require("Src.Core.Class")()
	Game.imageCachePool = {} -- 出现了全局变量且发生越界

----------------------------------------------------------------------

	正确的做法
	ResMgr.lua

	local _RESMGR = require("Src.Core.Class")()
	self.imageCachePool = {}

```
##### 5.单例类不用class化，只需使用空table定义即可
	单例类特指那些只出现一个实例的类，它们既不会重复出现，也不会作为基类存在，没有重用价值，因此不必class化，为其添加继承或重用的特性。
```lua
	
	example
	
	local _GAMEMGR = {
		
		tile = "Gear Of Fate",
		
		debug = false,
		
		keyboardIni = {}
	}

	local _RESMGR = {}
```
##### 6.Class中变量类型的定义方法
```lua
	public

	local _RESMGR = {} --单例类，纯table
	_RESMGR.imageCachePool = {}

-------------------------------------------------------

	private

	local _RESMGR ={} 
	
	function _RESMGR.Ctor()
		local _imageCachePool = {}
	end 

```
##### 7.table特性
	在lua中，table之间通过等号只能是一种引用，即复制根源变量的内存地址，而非变量内容的纯粹复制。

```lua
	
	example

	a = {x = 0}

	b = a

	b.x = 3

	print(a.x)

	输出结果不是0，而是3
```
	也就是说，b只是a传递出来的一个内存地址而已 
	
	b.x = 3 实质上会回到a中对a的x进行操作
	
	而当我们在一个文件中 local 定义类变量 最后再 return 它 
	
	那么当我们在外部需要使用它时，便可用require将其地址传递出来
	
	保存到一个新的变量中
	
```lua
	Mgr.lua

	local _MGR = {}

	_MGR.imageNum = 10

------------------------------------------------------------------
	
	ResPack.lua

	local _ResPack = require("Class")()

		local _MGR = require("Mgr")

	function _ResPack:Ctor()
		........
	end 

```
	在这里，看上去每次创建一个新的ResPack都会为其新建一个对应的MGR，
	
	实际上这种想法是错误的！
	
	(第一次require("Mgr")时，会在Mgr.lua文件内建立_MGR变量
	
	再次require时，就只会返回_MGR地址)
	
	ResPack.lua开头部分对Mgr的require只是为了将Mgr.lua中的_MGR地址传递出来
	
	方便使用而已，本质上并不是新建，而是添加了一个新的引用指针。
	
	正是通过这种方法 模块之间得以形成清晰的联系，同时又避免了严重的耦合。
	
	在这里这种一个MGR被多个ResPack引用的树形引用关系恰好就形成了
	
	MGR所需要的一种管理效应。



# 程序开发流程

### 1.需求分析（Need）
#### 书写需求文档
#### 确定功能函数（如：GameMgr包含 Ctor Update Draw …… ）
#### 确定包含的数据（如：GameMgr包含 title period screenOffset …… ）
#### 确定包含的单元(如：GameMgr包含GameMap HUD UI MonsterProducer……)
#### 确定模块性质（如：GameMgr是游戏的核心单元，它是所有大型单元Update和Draw的场所）
#### 使用astah pro 绘制UML图，理清各模块之间的关系（继承，组合……）

### 2.编程实现
#### 定义初期策划好的所有接口
#### 逐一编写接口内业务逻辑
#### Debug
---------------------------------------
## 参考资料：80/20 rule 思考代码时间占80% 编写时间占20% 这是一种必要的思维方式

### PS：基础薄弱 勤能补拙

</font>







